/*
 * MolPaintJS
 * Copyright 2017 Leibniz-Institut f. Pflanzenbiochemie
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var molPaintJS = (function (molpaintjs) {
    "use strict";

    /*
     * ToDo: history for collections, removal and replacement of
     * atoms and bonds in collections
     */
    molpaintjs.Molecule = function() {

        let properties = {};

        properties["COMMENT"] = "generated by MolPaintJS";
        properties["HEADER2"] = "";
        properties["NAME"] = "n.n.";

        let atoms = {};
        let bonds = {};
        let collections = [];
        let sgroups = {};
        let atomCount = 0;
        let bondCount = 0;
        let atomObjCount = 0;       // unique counter for atoms
        let bondObjCount = 0;       // unique counter for bonds
        let sgroupObjCount = 0;     // unique counter for sgroups

        return {

            addAtom : function (a, id) {
                atomObjCount++;
                if (id == null) {
                    id = "Atom" + atomObjCount;
                    a.setId(id);
                }
                atoms[id] = a;
                return id;
            },

            addBond : function (b, id) {
                bondObjCount++;
                if (id == null) {
                    id = "Bond" + bondObjCount;
                    b.setId(id);
                }
                bonds[id] = b;
                b.getAtomA().addBond(id);
                b.getAtomB().addBond(id);
                return id;
            },

            /**
             * called by parser; collections may be defined incrementally
             */
            addCollection : function (collection) {
                let merged = false;
                for (let c of collections) {
                    if (c.getName() === collection.getName()) {
                        c.merge(collection);
                        merged = true;
                    }
                }
                if (merged) {
                    return;
                }
                collections.push(collection);
            },

            addSGroup : function (sg, id) {
                sgroupObjCount++;
                if (id === null) {
                    id = "SGroup" + sgroupObjCount;
                    sg.setId(id);
                }
                sgroups[id] = sg;
                return id;
            },

            /**
             * adjust selections
             * @param match match all atoms and bonds where any of the given bits are set
             * @param clear clear given bits on all matching atoms, bonds and sgroups
             * @param set Set the given bits on all matching atoms, bonds and sgroups
             */
            adjustSelection : function (match, clear, set) {
                for (let id in atoms) {
                    let sel = atoms[id].getSelected();
                    if(sel & match) {

                        // order matters: first clear, then set
                        sel &= ~clear;
                        atoms[id].setSelected(sel | set);
                    }
                }
                for (let id in bonds) {
                    let sel = bonds[id].getSelected();
                    if(sel & match) {
                        sel &= ~clear;
                        bonds[id].setSelected(sel | set);
                    }
                }
                for (let id in sgroups) {
                    let sel = sgroups[id].getSelected();
                    if(sel & match) {
                        sel &= ~clear;
                        sgroups[id].setSelected(sel | set);
                    }
                }
            },

            /**
             * center the molecule according to its bounding box
             * i.e. move the center of the molecule to the point 0,0
             * @return the updated bounding box
             */
            center : function () {
                let bbox = this.computeBBox(0);

                let cx = -bbox.getCenterX();
                let cy = -bbox.getCenterY();

                for (let id in atoms) {
                    atoms[id].addX(cx);
                    atoms[id].addY(cy);
                    // ignore z
                }
                let b = molPaintJS.Box(
                    bbox.getMinX() + cx,
                    bbox.getMinY() + cy,
                    bbox.getMaxX() + cx,
                    bbox.getMaxY() + cy);
                return b;
            },

            /**
             * clear all selections
             * @param val All selections with bit val will be cleared.
             */
            clearSelection : function (val) {
                for (let id in atoms) {
                    let sel = atoms[id].getSelected();
                    if(sel & val) {
                        atoms[id].setSelected(sel & ~val);
                    }
                }
                for (let id in bonds) {
                    let sel = bonds[id].getSelected();
                    if(sel & val) {
                        bonds[id].setSelected(sel & ~val);
                    }
                }
                for (let id in sgroups) {
                    let sel = sgroups[id].getSelected();
                    if (sel & val) {
                        sgroups[id].setSelected(sel & ~val);
                    }
                }
            },

            /**
             * compute update history and clear temp flag
             * @return actionList containing update history
             */
            clearTemp : function ()  {
                let actionList = molPaintJS.ActionList();

                for (let id in atoms) {
                    if(atoms[id].getTemp() != 0) {
                        atoms[id].setTemp(0);
                        actionList.addAction(molPaintJS.Action("ADD", "ATOM", atoms[id], null));
                    }
                }
                for (let id in bonds) {
                    if(bonds[id].getTemp() != 0) {
                        bonds[id].setTemp(0);
                        actionList.addAction(molPaintJS.Action("ADD", "BOND", bonds[id], null));
                    }
                }
                return actionList;
            },

            /**
             * compute the bounding box coordinates of the current molecule
             * @param sel select bits which must be set when computing the
             * bounding box; if sel = 0, everything is selected
             */
            computeBBox : function (sel) {
                let bbox;
                let first = 0;

                for (let i in atoms) {
                    let a = atoms[i];
                    if ((sel === 0) || ((a.getSelected() & sel) != 0)) {
                        let x = a.getX();
                        let y = a.getY();
                        let z = a.getZ();
                        if (first == 0) {
                            bbox = molPaintJS.Box(x, y, x, y);
                            first = 1;
                        } else {
                            bbox.join(molPaintJS.Box(x, y, x, y));
                        }
                    }
                }
                return bbox;
            },

            /**
             * computes the median bond length in this molecule
             */
            computeBondLengths : function () {
                let bondLength = [];
                for (let i in bonds) {
                    let b = bonds[i];
                    let dx = b.getAtomA().getX() - b.getAtomB().getX();
                    let dy = b.getAtomA().getY() - b.getAtomB().getY();
                    let lensq = (dx * dx) + (dy * dy);
                    bondLength.push(lensq);
                }
                bondLength.sort(function (a, b) {
                    return a - b;
                });
                if (bondLength.length > 0) {
                    return Math.sqrt(bondLength[Math.floor(bondLength.length / 2)]);
                }
                return 1.5;     // default bond length
            },

            /**
             * deletes a single atom from this molecule
             * CAVEAT: this function does not perform any cross-check,
             * whether this atom is still part of a bond in this
             * molecule
             */
            delAtom : function (a) {
                let idx = a.getId();
                delete atoms[idx];
            },

            delBond : function (b) {
                let idx = b.getId();
                let bond = bonds[idx];
                bond.getAtomA().delBond(idx);
                bond.getAtomB().delBond(idx);
                delete bonds[idx];
            },

            /**
             * remove a collection from the list of collections
             * @param name the name of the collection to be removed
             */
            delCollection : function (name) {
                for (let i in collections) {
                    if (collections[i].getName() == name) {
                        collections.splice(i, 1);
                        return;
                    }
                }
            },

            /**
             * delete a SGroup
             */
            delSGroup : function (sg) {
                let idx = sg.getId();
                /*
                 * ToDo: remove sgroup from atoms and bonds
                 */
                delete sgroups[idx];
            },

            /**
             * delete all temporary bonds and atoms from the molecule
             */
            delTemp : function() {
                for(let b in bonds) {
                    if(bonds[b].getTemp() != 0) {
                        bonds[b].getAtomA().delBond(b);
                        bonds[b].getAtomB().delBond(b);
                        delete bonds[b];
                    }
                }
                for(let a in atoms) {
                    if(atoms[a].getTemp() != 0) {
                        delete atoms[a];
                    }
                }
            },

            getAtom : function (id) {
                return atoms[id];
            },

            getAtomCount : function () {
                return atomCount;
            },

            getAtoms : function () {
                return atoms;
            },

            getBond : function (id) {
                return bonds[id];
            },

            getBondCount : function () {
                return bondCount;
            },

            getBonds : function () {
                return bonds;
            },

            getCollections : function () {
                return collections;
            },

            getProperties : function () {
                return properties;
            },

            getProperty : function (propname) {
                return properties[propname];
            },

            /**
             * @param sel selection bits
             * @return the atoms and bonds which match the given selection bits
             */
            getSelected : function (sel) {
                let result = {atoms: [], bonds: []};
                for (let id in atoms) {
                    if ((atoms[id].getSelected() & sel) != 0) {
                        result.atoms.push(id);
                    }
                }
                for (let id in bonds) {
                    if ((bonds[id].getSelected() & sel) != 0) {
                        result.bonds.push(id);
                    }
                }
                return result;
            },

            getSGroup : function (idx) {
                return sgroups[idx];
            },

            getSGroups : function () {
                return sgroups;
            },

            /**
             * assign a numeric index to all atoms and bonds
             */
            reIndex : function () {
                let i = 1;
                for (let id in atoms) {
                    let a = atoms [id];
                    a.setIndex(i);
                    i++;
                }
                atomCount = i - 1;

                i = 1;
                for (let id in bonds) {
                    let b = bonds[id];
                    b.setIndex(i);
                    i++;
                }
                bondCount = i - 1;
            },

            /**
             * replace an atom in the atom list and all
             * bonds. The IDs of the atoms must be identical.
             * @param a atom
             */
            replaceAtom : function (a) {
                let id = a.getId();
                let o = atoms[id];
                if (o == null) {
                    alert("Molecule.replaceAtom() called for non-existing atom.");
                    return;
                }
                for (let i in a.getBonds()) {
                    let b = bonds[i];
                    if (b.getAtomA().getId() == id) {
                        b.setAtomA(a);
                    } else {
                        b.setAtomB(a);
                    }
                }
                atoms[id] = a;
            },

            /**
             * replace a bond in the bond list. The IDs of the
             * bonds must be identical. The bond lists
             * of the atoms are not affected, because they contain
             * only bond IDs.
             */
            replaceBond : function (b) {
                let id = b.getId();
                let o = bonds[id];
                if (o == null) {
                    alert("Molecule.replaceBond() called for non-existing bond.");
                    return;
                }
                bonds[id] = b;
            },

            /**
             * select the first matching atom
             * @param coords the coordinates
             * @param distmax maximum squared euclidian distance
             * @return atomId
             */
            selectAtom : function (coords, distmax) {
                for (let id in atoms) {
                    let a = atoms[id];
                    let dx = a.getX() - coords.x;
                    let dy = a.getY() - coords.y;
                    if (distmax > ((dx * dx) + (dy * dy))) {
                        return id;
                    }
                }
                return null;
            },

            /**
             * return a list of atom id's and a list of bond id's,
             * which are enclosed by the given bounding box.
             * Enclosed atoms and bonds are marked as selected.
             * @param bbox bounding box in molecule coordinates
             * @param val bit value to set on selected entities
             * @param cond bits which must not be set for selection of an entity
             * @return an object with properties "atoms" and "bonds"
             */
            selectBBox : function (bbox, val, cond) {
                let result = {atoms: [], bonds: []};
                for (let id in atoms) {
                    let atom = atoms[id];
                    let sel = atom.getSelected();
                    if ((sel & cond) === 0) {
                        if (bbox.contains(atom.getX(), atom.getY())) {
                            atom.setSelected(sel | val);
                            result.atoms.push(id);
                        }
                    }
                }
                for (let id in bonds) {
                    let bond = bonds[id];
                    let sel = bond.getSelected();
                    if ((sel & cond) === 0) {
                        let atomA = bond.getAtomA();
                        let atomB = bond.getAtomB();
                        if (bbox.contains(atomA.getX(), atomA.getY()) &&
                            bbox.contains(atomB.getX(), atomB.getY())) {
                            bond.setSelected(sel | val);
                            result.bonds.push(id);
                        }
                    }
                }
                return result;
            },

            /**
             * return a list of matching bonds
             * @param coords coordinates of action
             * @param distmax maximum squared euclidian distance
             * @param returns an array of matching bonds; array may be empty
             */
            selectBond : function (coords, distmax) {
                let matches = [];
                for (let id in bonds) {
                    let b = bonds[id];
                    let dx = b.getAtomA().getX() - b.getAtomB().getX();
                    let dy = b.getAtomA().getY() - b.getAtomB().getY();
                    let l = Math.sqrt(dx * dx + dy * dy);

                    l = (l < 0.01) ? 1.0 : l;   // guard against division by zero

                    let bx = coords.x - b.getAtomB().getX();
                    let by = coords.y - b.getAtomB().getY();

                    let sin = dy / l;
                    let cos = dx / l;

                    let rx = bx * cos + by * sin;
                    let ry = -bx * sin + by * cos

                    if ((rx > 0) && (rx < l) && ((ry * ry) < distmax)) {
                        matches.push(id);
                    }

                }
                return matches;
            },

            /**
             * replace a Collection of this Molecule by the Collection
             * given as an argument. If the Collection does not yet
             * exist, append it to the list of Collections.
             * @param collection the collection object with modified data
             */
            setCollection : function (collection) {
                for (let i in collections) {
                    if (collections[i].getName() == collection.getName()) {
                        collections[i] = collection;
                        return;
                    }
                }
                collections.push(collection);
            },

            setProperty : function (propname, propval) {
                properties[propname] = propval;
            },

            /**
             * 2d-transforms the coordinates of this molecule.
             * The z-coordinate is not affected!
             * @param matrix a 2x3 transformation matrix
             * @param sel select bits to which the transformation should apply (set to
             * zero to apply transformation to all atoms)
             */
            transform : function (matrix, sel) {
                for (let id in atoms) {
                    let atom = atoms[id];
                    if ( (sel === 0) || ((atom.getSelected() & sel) != 0)) {
                        let x = atom.getX();
                        let y = atom.getY();
                        atom.setX(matrix[0][0] * x + matrix[0][1] * y + matrix[0][2]);
                        atom.setY(matrix[1][0] * x + matrix[1][1] * y + matrix[1][2]);
                    }
                }
            }
        };
    }
    return molpaintjs;
}(molPaintJS || {}));
